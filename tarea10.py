# -*- coding: utf-8 -*-
"""Tarea10.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iTAYx5lpdBlanmGSOc0wxukquu1qhxJA
"""

from queue import PriorityQueue

direcciones = [(-1, 0), (1, 0), (0, -1), (0, 1)]

def distancia_manhattan(x1, y1, x2, y2):
    return abs(x1 - x2) + abs(y1 - y2)

# Resuelve el laberinto utilizando Ramificación y Poda con BFS y distancia de Manhattan
def resolver_laberinto(laberinto, inicio, salida):
    # Cola de prioridad para BFS con heurística (distancia + pasos)
    cola_prioridad = PriorityQueue()
    cola_prioridad.put((0, inicio[0], inicio[1], 0, [(inicio[0], inicio[1])]))

    # Conjunto de visitados para evitar revisitar nodos
    visitados = set()
    visitados.add((inicio[0], inicio[1]))

    while not cola_prioridad.empty():
        # Extrae el nodo con la menor heurística
        heuristica, x, y, pasos, camino = cola_prioridad.get()
        print(f"Visitando: ({x}, {y}), Pasos: {pasos}, Heurística: {heuristica}")

        # Si llegamos al final, devolvemos el número de pasos y el camino
        if (x, y) == salida:
            print("Camino encontrado:", camino)
            return pasos

        # Explora los movimientos posibles
        for dx, dy in direcciones:
            nx, ny = x + dx, y + dy

            # Verifica que el movimiento esté dentro del laberinto y sea una celda accesible
            if 0 <= nx < len(laberinto) and 0 <= ny < len(laberinto[0]) and laberinto[nx][ny] in ('c', 's'):
                if (nx, ny) not in visitados:
                    visitados.add((nx, ny))
                    # Calcula la nueva heurística: pasos + distancia Manhattan
                    nueva_heuristica = pasos + 1 + distancia_manhattan(nx, ny, salida[0], salida[1])
                    nuevo_camino = camino + [(nx, ny)]
                    cola_prioridad.put((nueva_heuristica, nx, ny, pasos + 1, nuevo_camino))

    print("No se encontró un camino hasta la salida.")
    return -1

laberinto = [
    ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
    ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
    ['p', 'p', 'p', 'p', 'c', 'p', 'p', 'p'],
    ['p', 'c', 'c', 'c', 'c', 'c', 'c', 'p'],
    ['p', 'c', 'p', 'c', 'p', 'p', 'c', 'p'],
    ['p', 'c', 'p', 'c', 'p', 'p', 'c', 'p'],
    ['p', 'c', 'p', 'c', 'c', 'c', 'c', 'p'],
    ['p', 'c', 'p', 'c', 'p', 'p', 'c', 'p'],
    ['p', 'c', 'c', 'c', 'c', 'p', 'c', 'p'],
    ['p', 'p', 'p', 'p', 'c', 'c', 'c', 's'],
    ['p', 'p', 'c', 'p', 'c', 'p', 'p', 'p'],
    ['p', 'c', 'c', 'c', 'c', 'c', 'p', 'p'],
    ['p', 'p', 'c', 'p', 'p', 'c', 'p', 'p'],
    ['p', 'p', 'E', 'p', 'p', 'p', 'p', 'p']
]

inicio = (13, 2)
salida = (9, 7)

pasos = resolver_laberinto(laberinto, inicio, salida)
if pasos != -1:
    print(f"Se encontró un camino hasta la salida en {pasos} pasos.")
else:
    print("No se encontró un camino hasta la salida.")